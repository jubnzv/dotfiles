# -*- mode: org; -*-

* About

This is my Emacs configuration file written as Org document.

** Resources

*** Guides
+ [[https://github.com/noctuid/evil-guide][noctuid/evil-guide]]
+ Article: [[How to read Emacs Lisp][http://emacslife.com/how-to-read-emacs-lisp.html]]

*** Dotfiles
+ [[https://github.com/caisah/emacs.dz][caisah/emacs.dz]] - Awesome emacs config files including nice evil configurations.
+ [[https://github.com/andreyorst/dotfiles/tree/master/.emacs.d][andreyorst]] - Clean and easy to read emacs configuration in org-mode
+ [[https://github.com/IvanMalison/dotfiles][IvanMalison]]

* User info

#+BEGIN_SRC emacs-lisp
(setq user-full-name
  (replace-regexp-in-string "\n$" ""
  (shell-command-to-string "git config --get user.name")))
(setq user-mail-address
  (replace-regexp-in-string "\n$" ""
  (shell-command-to-string "git config --get user.email")))
#+END_SRC

* Packages

Initialize package manager:
#+BEGIN_SRC emacs-lisp
(require 'package)
(setq package-enable-at-startup nil)
(add-to-list 'package-archives
    '("melpa" . "https://melpa.org/packages/") t)
(package-initialize)
(when (not package-archive-contents) (package-refresh-contents))
#+END_SRC

Bootstrap use-package:
#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(require 'use-package)
(setq use-package-always-ensure t)
#+END_SRC

Load use-package extensions:

The ~:chords~ keyword allows you to define key-chord bindings for use-package declarations in the same manner as the :bind keyword.

#+BEGIN_SRC emacs-lisp
(use-package use-package-chords
  :ensure t
  :config (key-chord-mode 1))
#+END_SRC

* UI

#+BEGIN_SRC emacs-lisp
(ignore-errors
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (tooltip-mode -1)
  (fset 'menu-bar-open nil))
#+END_SRC

** Use ~y~/~n~ instead ~yes~/~no~
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Disable cursor blinking
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
#+END_SRC

** Window title

Show file name and mode in window title:
#+BEGIN_SRC emacs-lisp
(setq-default frame-title-format '("%b (%m) â€” Emacs"))
#+END_SRC

** Highlight matching parens
#+BEGIN_SRC emacs-lisp
(show-paren-mode t)
#+END_SRC

** Show trailing whitespaces in essential modes

#+BEGIN_SRC emacs-lisp
(setq-default whitespace-style '(face trailing spaces space-mark))
(add-hook 'prog-mode-hook (lambda () (setq show-trailing-whitespace t)))
(add-hook 'org-mode-hook (lambda () (setq show-trailing-whitespace t)))
#+END_SRC

To available it in all buffers enable that:
#+BEGIN_SRC emacs-lisp :tangle no
(setq-default show-trailing-whitespace t)
#+END_SRC


** Highlight current line
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode t)
#+END_SRC

** Show columns numbers
#+BEGIN_SRC emacs-lisp
(column-number-mode)
#+END_SRC

** Show line numbers
#+BEGIN_SRC emacs-lisp
(setq-default display-line-numbers-current-absolute t)
(setq-default display-line-numbers 'visual)
#+END_SRC

** ~redisplay-dont-pause~
The variable ~redisplay-dont-pause~, when set to t, will cause Emacs to fully redraw the display before it processes queued input events.
Futher explantation: https://www.masteringemacs.org/article/improving-performance-emacs-display-engine
#+BEGIN_SRC emacs-lisp
(setq redisplay-dont-pause t)
#+END_SRC

** Modeline configuration
#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :ensure t
  :defer t
  :config
  (setq doom-modeline-height 15)
  (setq doom-modeline-icon nil)
  :hook (after-init . doom-modeline-init))
#+END_SRC

** Color scheme
#+BEGIN_SRC emacs-lisp
(use-package gruvbox-theme
  :ensure t
  :init
  (load-theme 'gruvbox t))
#+END_SRC

** Font
#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil :font "Iosevka-12")
#+END_SRC

* Emacs default options

** Initial buffer
Instead default startup screen open ~*scratch*~ with org-mode:
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t)
(setq initial-scratch-message nil)
(setq initial-major-mode 'org-mode)
#+END_SRC

** scrolloff
#+BEGIN_SRC emacs-lisp
(setq scroll-margin 7)
#+END_SRC

** Undo-tree

There are no standard way to implement persistent undo in Emacs. I use modified solution from [[https://github.com/syl20bnr/spacemacs/issues/774][this issue]].

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :config
  (setq undo-tree-auto-save-history t
        undo-tree-history-directory-alist
        `(("." . ,(concat user-emacs-directory "undo"))))
  (unless (file-exists-p (concat user-emacs-directory "undo"))
  (make-directory (concat user-emacs-directory "undo")))
  (global-undo-tree-mode 1))
#+END_SRC

** Save buffer position after exit
#+BEGIN_SRC emacs-lisp
(save-place-mode 1)
#+END_SRC

** Disable bell
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC

** Custom file
#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file :noerror)
#+END_SRC

** Keep backup files in separate directory
#+BEGIN_SRC emacs-lisp
    (setq backup-by-copying t
        create-lockfiles nil
        backup-directory-alist '(("." . "~/.cache/emacs-backups"))
        auto-save-file-name-transforms '((".*" "~/.cache/emacs-backups" t)))
#+END_SRC

** Disable auto save
#+BEGIN_SRC emacs-lisp
(setq auto-save-default nil)
#+END_SRC

** Use system clipboard
#+BEGIN_SRC emacs-lisp
(setq x-select-enable-clipboard t)
#+END_SRC

** Treat underscore as part of the word

This is default behaviour in vim.
#+BEGIN_SRC emacs-lisp
(modify-syntax-entry ?_ "w")
#+END_SRC

* Evil mode and common keybindings

** Bootstrap Evil
#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t
  :init
  (setq evil-search-module 'evil-search)
  (setq evil-want-C-i-jump nil) ;; fix TAB key behaviour in evil-org extension
  (setq evil-ex-complete-emacs-commands nil)
  (setq evil-vsplit-window-right t)
  (setq evil-split-window-below t)
  (setq evil-shift-round nil)
  (setq evil-want-C-u-scroll t)
  :config
  (evil-mode))
#+END_SRC

** Essential key bindings

Here is most essential keybindings that available in every major mode.

*** ~<Space>~ is my leader
#+BEGIN_SRC emacs-lisp
(defvar evil-leader-map (make-sparse-keymap)
    "Keymap for \"leader key\" shortcuts.")
(define-key evil-normal-state-map (kbd "SPC") evil-leader-map)
#+END_SRC

*** ~jj~ to leave insert mode:
#+BEGIN_SRC emacs-lisp
(use-package key-chord
  :config
  (key-chord-define evil-insert-state-map "jj" 'evil-normal-state))
#+END_SRC

*** Common Emacs commands

Similar approach is used in excellent Chen Bin's [[https://github.com/redguardtoo/emacs.d/][dotfiles]].
#+BEGIN_SRC emacs-lisp
(define-key evil-leader-map "xf" 'counsel-find-file)
(define-key evil-leader-map "xs" 'save-buffer)
(define-key evil-leader-map "s" 'save-buffer)
(define-key evil-leader-map "xk" 'kill-buffer)
(define-key evil-leader-map "xc" 'save-buffers-kill-terminal)
(define-key evil-leader-map " " 'counsel-M-x)
#+END_SRC

*** Reload configuration file
#+BEGIN_SRC emacs-lisp
(define-key evil-leader-map "R"  (lambda() (interactive)(load-file "~/.emacs.d/init.el")))
#+END_SRC

*** :noh
#+BEGIN_SRC emacs-lisp
(define-key evil-leader-map "h"  'evil-ex-nohighlight)
#+END_SRC

*** Use ~C-s~ to save current buffer

Disabled for now. It's terrible habit, because it may causes ~Software Flow Control~ mode activation in some terminals.
#+BEGIN_SRC emacs-lisp :tangle no
(global-set-key (kbd "C-s") 'save-buffer)
#+END_SRC

*** Remove trailing whitespaces
#+BEGIN_SRC emacs-lisp
(define-key evil-leader-map "es"  'delete-trailing-whitespace)
#+END_SRC

*** Instant access to config.org

#+BEGIN_SRC emacs-lisp
(defun open-org-config-file ()
  "Open Emacs configuration file in another window."
  (interactive)
  (find-file-other-window (expand-file-name "config.org" user-emacs-directory)))

(define-key evil-leader-map "CC"  'open-org-config-file)
#+END_SRC

** Avy

It works like [[https://github.com/easymotion/vim-easymotion][easymotion]].

#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :config
  (global-set-key (kbd "M-;") 'avy-goto-char)
  (global-set-key (kbd "M-C-;") 'avy-resume))
#+end_SRC
** Which-key mode

[[https://github.com/justbur/emacs-which-key][which-key]] is a package that displays available keybindings in popup.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :after evil
  :config
  (setq which-key-allow-evil-operators t)
  (which-key-mode))
#+END_SRC

** Evil mode integration
*** Evil mode inside M-x package-list-packages

See following [[https://www.reddit.com/r/emacs/comments/7dsm0j/how_to_get_evilmode_hjkl_to_work_inside_mx/][reddit post]] for more.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'evil
  ;; use evil mode in the buffer created from calling `list-packages'.
  (add-to-list 'evil-buffer-regexps '("*Packages*" . normal))
  (with-eval-after-load 'package
  ;; movement keys j,k,l,h set up for free by defaulting to normal mode.
  ;; mark, unmark, install
  (evil-define-key 'normal package-menu-mode-map (kbd "m") #'package-menu-mark-install)
  (evil-define-key 'normal package-menu-mode-map (kbd "u") #'package-menu-mark-unmark)
  (evil-define-key 'normal package-menu-mode-map (kbd "x") #'package-menu-execute)))
#+END_SRC

*** Evil surround
#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :ensure t
  :config
  (global-evil-surround-mode 1))
#+END_SRC

*** Evil nerdcommenter

#+BEGIN_SRC emacs-lisp
(use-package evil-nerd-commenter
  :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(define-key evil-leader-map "ci" 'evilnc-comment-or-uncomment-lines)
(define-key evil-leader-map "cl" 'evilnc-quick-comment-or-uncomment-to-the-line)
(define-key evil-leader-map "ll" 'evilnc-quick-comment-or-uncomment-to-the-line)
(define-key evil-leader-map "cc" 'evilnc-copy-and-comment-lines)
(define-key evil-leader-map "cp" 'evilnc-comment-or-uncomment-paragraphs)
(define-key evil-leader-map "cr" 'comment-or-uncomment-region)
(define-key evil-leader-map "cr" 'comment-or-uncomment-region)
(define-key evil-leader-map "cv" 'evilnc-toggle-invert-comment-line-by-line)
(define-key evil-leader-map "."  'evilnc-copy-and-comment-operator)
#+END_SRC

*** Evil-org
#+BEGIN_SRC emacs-lisp
(use-package evil-org
  :ensure t
  :after (evil org)
  :config
  (add-hook 'org-mode-hook 'evil-org-mode)
  (add-hook 'evil-org-mode-hook
            (lambda () (evil-org-set-key-theme))))
#+END_SRC

* Fuzzy completion with ivy & co

These three tools are available in a single github [[https://github.com/abo-abo/swiper][repository]].

** Ivy

*Ivy* - a generic completion frontend for Emacs.
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :ensure t
  :config
  (ivy-mode 1))
#+END_SRC

** Counsel

*Counsel* - a collection of Ivy-enhanced versions of common Emacs commands.
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :ensure t
  :config
  (setcdr (assoc 'counsel-M-x ivy-initial-inputs-alist) "") ;; Remove initial "^"
  (global-set-key (kbd "M-x") 'counsel-M-x)
  ;; Set matching style
  (setq ivy-re-builders-alist
    '((swiper . ivy--regex-plus)
      (counsel-rg . ivy--regex-plus)
      (counsel-projectile-switch-project . ivy--regex-plus)
      (counsel-projectile-rg . ivy--regex-plus)
      (t . ivy--regex-plus))))
#+END_SRC

** Swiper

*Swiper* - isearch with an overview. It looks like :Ag command in fzf.vim, but it works without any external tools.
#+BEGIN_SRC emacs-lisp
(use-package swiper
  :ensure t)
#+END_SRC

** Keybindings

Following keybindings are very similar to FZF section in my vim/zsh configuration.

#+BEGIN_SRC emacs-lisp
(define-key ivy-minibuffer-map (kbd "<escape>") 'minibuffer-keyboard-quit)
(define-key ivy-minibuffer-map (kbd "M-q") 'minibuffer-keyboard-quit)
(define-key ivy-minibuffer-map (kbd "M-j") 'ivy-next-line)
(define-key ivy-minibuffer-map (kbd "M-k") 'ivy-previous-line)
(define-key ivy-minibuffer-map (kbd "M-l") 'ivy-alt-done)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(define-key evil-leader-map "b"  'ivy-switch-buffer)
(define-key evil-leader-map "fs" 'counsel-rg)
#+END_SRC
* org-mode

** General options

Enable soft-wrap:
#+BEGIN_SRC emacs-lisp
(setq org-startup-truncated nil)
#+END_SRC

Show inline images (~file:/~ links):
#+BEGIN_SRC emacs-lisp
(setq org-startup-with-inline-images t)
#+END_SRC

** Keybindings

Generally, I use ~,~ prefix as local leader for org-mode commands.

#+BEGIN_SRC emacs-lisp
(evil-declare-key 'normal org-mode-map
  "<" (lambda () (interactive) (org-demote-or-promote 1)) ; out-dent
  ">" 'org-demote-or-promote) ; indent
#+END_SRC

Disable ~evil-auto-indent~ for org-mode. Using to prevent annoying ~O~/~o~ behaviour.
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook (lambda () (setq evil-auto-indent nil)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(evil-declare-key 'normal org-mode-map ",f" 'counsel-org-goto)
(evil-declare-key 'normal org-mode-map ",t" 'counsel-org-tag)
(evil-declare-key 'normal org-mode-map ",cl" 'org-insert-link)
#+END_SRC

** Embedded code blocks

Allow code evaluation with ~org-babel-execute~ (~C-c C-c~):
#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages 'org-babel-load-languages '(
  (shell . t)
  (python . t)))
#+END_SRC

** Download images to org-mode

How to use it:
1. Copy image URI
2. Call ~org-download-yank~ (~, D y~).
Image will be saved in ~./images~ directory and embedded in org file.

*** Custom download function

Thanks to [[https://gist.github.com/daviderestivo/ad3dfa38d3f7266d014ce469aafd18dc][daviderestivo]].

This is an helper function for org-download. It creates an \"./image\" folder within the same directory of the org file.
Images are separated inside that image folder by additional folders one per org file.

/Links/:
+ More info can be found [[https://github.com/abo-abo/org-download/issues/40][here]]
+ Usage example in [[https://github.com/abo-abo/org-download/commit/137c3d2aa083283a3fc853f9ecbbc03039bf397b][commit message]]

#+BEGIN_SRC emacs-lisp
(defun jubnzv/org-download-method (link)
  (let ((filename
         (file-name-nondirectory
          (car (url-path-and-query
                (url-generic-parse-url link)))))
        (dir (concat
              (file-name-directory (buffer-file-name))
              (format "%s/%s/%s"
                      "images"
                      (file-name-base (buffer-file-name))
                      (org-download--dir-2)))))
    (progn
      (setq filename-with-timestamp (format "%s%s.%s"
                                            (file-name-sans-extension filename)
                                            (format-time-string org-download-timestamp)
                                            (file-name-extension filename)))
      ;; Check if directory exists otherwise creates it
      (unless (file-exists-p dir)
        (make-directory dir t))
      (message (format "Image: %s saved!" (expand-file-name filename-with-timestamp dir)))
(expand-file-name filename-with-timestamp dir))))
#+END_SRC

*** Plugin initialization
#+BEGIN_SRC emacs-lisp
(use-package org-download
  :ensure t
  :config
  (setq org-download-method 'jubnzv/org-download-method)
  ;; Drag-and-drop to `dired`
  (add-hook 'dired-mode-hook 'org-download-enable))
#+END_SRC

*** Keybindings
#+BEGIN_SRC emacs-lisp
(evil-declare-key 'normal org-mode-map ",Dy" 'org-download-yank)
#+END_SRC

* Hugo integration

Integration layer for [[https://gohugo.io][hugo]] static site generator.

#+BEGIN_SRC emacs-lisp
(use-package easy-hugo
  :ensure t
  :init
  (setq easy-hugo-basedir "~/Idie/")
  (setq easy-hugo-url "https://idie.ru/")
  (setq easy-hugo-root "~/Idie/public/")
  (setq easy-hugo-postdir "~/Idie/content/notes/")
  (setq easy-hugo-previewtime "300"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(define-key evil-leader-map "H"  'easy-hugo)
#+END_SRC

* Snippets

Collection of snippets:

#+BEGIN_SRC emacs-lisp
(use-package yasnippet-snippets :ensure t)
#+END_SRC

Initialize ~yasnippet~ plugin itself:

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :after yasnippet-snippets)
#+END_SRC

* Auto parens
#+begin_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :config
  (smartparens-global-mode))
#+END_SRC

* Spell checking

ispell can be configured to skip over regions that match regexes.

#+BEGIN_SRC emacs-lisp
(add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
(add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_EXAMPLE" . "#\\+END_EXAMPLE"))
#+END_SRC

* Programming facilities

I start using Emacs for some of my Rust experiments.

** Indentation

*** Display the indention levels with thin vertical lines

Alternative to vim's [[https://github.com/Yggdroot/indentLine][indentLine]] plugin.

#+BEGIN_SRC emacs-lisp
(use-package highlight-indent-guides
  :ensure t
  :config
  (setq highlight-indent-guides-method 'character)
  (add-hook 'prog-mode-hook 'highlight-indent-guides-mode))
#+END_SRC

** Magit: git integration layer

*** Initialization
#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t)
#+END_SRC

*** Integration with evil-mode
#+BEGIN_SRC emacs-lisp
(use-package evil-magit
  :after (evil magit)
  :ensure t
  :config
  (setq evil-magit-state 'normal))
#+END_SRC

*** git-gutter
#+BEGIN_SRC emacs-lisp
(use-package git-gutter
  :ensure t
  :config
  (global-git-gutter-mode +1))
#+END_SRC

*** Keybindings

~<leader>v~ prefix.

#+BEGIN_SRC emacs-lisp
(define-key evil-leader-map "vs"  'magit-status)
#+END_SRC

** Projectile

This plugin is required to keep current directory when moving through project files.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :diminish projectile-mode
  :init
  (projectile-mode +1))
#+END_SRC

Use Ivy UI for Projectile:
#+BEGIN_SRC emacs-lisp
(use-package counsel-projectile
  :ensure t
  :config
  ; Open magit-status after switch project.
  ; See: https://github.com/ericdanan/counsel-projectile/issues/62
  ; (counsel-projectile-modify-action
  ;  'counsel-projectile-switch-project-action
  ;  '((default counsel-projectile-switch-project-action-vc)))
)
#+END_SRC

Keybindings:
#+BEGIN_SRC emacs-lisp
(define-key evil-leader-map "pp"  'counsel-projectile-switch-project)
(define-key evil-leader-map "pf"  'counsel-projectile-find-file)
(define-key evil-leader-map "pd"  'counsel-projectile-find-dir)
(define-key evil-leader-map "pb"  'counsel-projectile-switch-to-buffer)
(define-key evil-leader-map "pD"  'projectile-dired)
(define-key evil-leader-map "pR"  'projectile-toggle-project-read-only)
(define-key evil-leader-map "pK"  'projectile-kill-buffers)
(define-key evil-leader-map "pT"  'projectile-regenerate-tags)
(define-key evil-leader-map "pS"  'projectile-run-eshell)
(define-key evil-leader-map "pM"  'projectile-compile-project)
(define-key evil-leader-map "pC"  'projectile-configure-project)
(define-key evil-leader-map "pv"  'projectile-vc)
#+END_SRC

** ctags

#+BEGIN_SRC emacs-lisp
(use-package counsel-etags
  :ensure t)

(define-key evil-leader-map "ft" 'counsel-etags-find-tag)
#+END_SRC

** LSP

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :commands lsp
  :config
  (setq lsp-highlight-symbol-at-point nil))

(use-package lsp-ui :commands lsp-ui-mode)
#+END_SRC

Backend for company:
#+BEGIN_SRC emacs-lisp
(use-package company-lsp
  :ensure t)
#+END_SRC

** Autocompletion with company-mode

Company is a text completion framework for Emacs that very similar with vim's deoplete.
#+begin_SRC emacs-lisp
(use-package company
  :ensure t
  :diminish company-mode
  :config
  (setq company-tooltip-limit 20)
  (setq company-idle-delay 0)
  (global-company-mode 1))
#+END_SRC

#+begin_SRC emacs-lisp
(define-key company-active-map (kbd "M-j") 'company-select-next)
(define-key company-active-map (kbd "M-k") 'company-select-previous)
(define-key company-active-map (kbd "M-l") 'company-complete-common)
(define-key company-search-map (kbd "M-j") 'company-select-next)
(define-key company-search-map (kbd "M-k") 'company-select-previous)
(define-key company-search-map (kbd "M-l") 'company-complete-common)
#+END_SRC

** Rust

#+BEGIN_SRC emacs-lisp
(use-package rust-mode
  :ensure t)
#+END_SRC
* Learning Emacs

** Track frequently used commands with ~keyfreq~

The frequently used commands should be assigned efficient key bindings.
See this [[http://blog.binchen.org/posts/how-to-be-extremely-efficient-in-emacs.html][post]] by Bin Chen.

See generated report with ~keyfreq-html~.

#+BEGIN_SRC emacs-lisp
(use-package keyfreq
  :ensure t
  :config
  ; Exclude most common commands
  (setq keyfreq-excluded-commands
      '(forward-char
        backward-char
        previous-line
        next-line
	save-buffer
	; self-insert-command
        ; See: http://emacshorrors.com/posts/self-insert-command.html
	self-insert-command
	org-self-insert-command
	; Evil
	evil-delete-backward-char-and-join
	evil-normal-state
	evil-jump-backward
	evil-forward-char
	evil-backward-char
	evil-org-delete-char
	evil-insert
	evil-previous-line
	evil-next-line
	evil-ex-nohighlight
	evil-forward-word-begin
	evil-backward-word-begin))
  (setq keyfreq-file "~/.emacs.d/keyfreq"
	keyfreq-file-lock "~/.emacs.d/keyfreq.lock")
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1))
#+END_SRC

** Log called commands in a buffer

Useful to find called commands names to bind them later.
#+BEGIN_SRC emacs-lisp
(use-package command-log-mode
  :ensure t
  :config
  (add-hook 'org-mode-hook 'command-log-mode))
#+END_SRC

* Hooks to set everything up

When using ~emacsclient~, some settings do not get set in the newly created frame.

I have now removed any customization options that requires this hooks. But it may be very useful later.

#+BEGIN_SRC emacs-lisp :tangle no
(defvar jubnzv:appearance-setup-done nil)

defun jubnzv:appearance-setup-hook (&rest args)
  (unless jubnzv:appearance-setup-done
    (apply 'jubnzv:appearance args)
    (setq jubnzv:appearance-setup-done t)))

(if (daemonp)
  (add-hook 'after-make-frame-functions 'jubnzv:appearance-setup-hook)
  (add-hook 'after-init-hook 'jubnzv:appearance-setup-hook))
#+END_SRC
