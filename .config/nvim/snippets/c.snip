# {{{ Abbrevations for common calls
snippet     exf
    exit(EXIT_FAILURE);
snippet     exs
    exit(EXIT_SUCCESS);
snippet     pe
    perror("$0");
# }}}

# {{{ Include-Guard
snippet     once
options     head
alias       include-guard
abbr #ifndef ... #define ... #endif
    #ifndef ${1:#:SYMBOL}
        #define $1

        ${0:TARGET}
    #endif /* !$1 */
# }}}

# {{{ Printing
snippet pr
abbr    printf("...\n", ...);
    printf("${1}\n"${2});
snippet prp
    printf("%ld: ${1}\n", (long)getpid()${2});
snippet prpp
    printf("%ld:%ld: ${1}\n", (long)getppid(), (long)getpid()${2});
snippet prt
    printf("%ld: ${1}\n", (long)pthread_self()${2});

# {{{ Debug prints
# :g/\/\/\ prdbg$/d to clean them all
snippet     prd
alias       prdbg
options     head
    printf("%s:%d ${1}\n", __func__, __LINE__${2}); // prdbg
snippet     prdh
options     head
    printf("%s:%d\n", __func__, __LINE__); // prdbg
snippet     prda
options     head
    printf("%s:%d ${1}=%${2:fmt}\n", __func__, __LINE__, $1); // prdbg
    ${0}
snippet     prdk
options     head
    printk("%s:%d ${1}\n", __func__, __LINE__${2}); // prdbg
# }}}

# Print bits of integer
snippet prb
options head
alias   print-bits
    int i;
    for (i = 0; i < ${1:#:NB}; i++) {
        printf("%c", (${2:#:SRC} & (1 << i)) ? '1' : '0');
        if ((i + 1) % 16 == 0)
            printf("\n");
    }

# }}}

# {{{ Bitwise
# Set a bit
snippet     bws
# abbr |=
    |= (1 << ${0:BIT})

# Clear a bit
snippet     bwc
# abbr &=
    &= ~(1 << ${0:BIT})

# Toggle a bit
snippet     bwt
# abbr ^=
    ^= (1 << ${0:BIT})

# Test a bit
snippet     bwtt
    & (1 << ${0:BIT})

# }}}

# {{{ Comments
snippet cmret
    0 if success, -1 otherwise
snippet cmrete
    0 if success, -1 and sets errno otherwise

snippet     cmft
options     head
    /* clang-format off */
        ${0}
    /* clang-format on */
# }}}

# {{{ fork
# Common
snippet     frk
options     head
abbr        fork ()
    switch (child_pid = fork()) {
    case -1:
        perror("fork");
        exit(EXIT_FAILURE);
    case 0: {
        ${0:TARGET}
        exit(EXIT_SUCCESS);
    }
    default:
        break;
    }

# Avoid race condition after fork with signals (see TLPI 24.4).
# Parent first.
snippet     frksigp
options     head
    switch (child_pid = fork()) {
    case -1:
        perror("fork");
        exit(EXIT_FAILURE);
    case 0:
        /* Waits for parent signal */
        sigemptyset(&empty_mask);
        if (sigsuspend(&empty_mask) == -1 && errno != EINTR) {
            perror("sigsuspend");
            exit(EXIT_FAILURE);
        }

        ${0:CHILD_ACTIONS}
        exit(EXIT_SUCCESS);
    default:
        ${0:PARENT_ACTIONS}

        /* Awake child */
        if (kill(child_pid, SYNC_SIG) == -1) {
            perror("kill");
            exit(EXIT_FAILURE);
        }
        break;
    }
# }}}

# {{{ signals
snippet     sig
options     head
    struct sigaction sa;
    sa.sa_flags = ${1:flags};
    sa.sa_handler = ${2:handler};
    sigaction(SIG${3:signal}, &sa, NULL);
# }}}

# {{{ waitpid
snippet     wpid
options     head
abbr        waitpid()
    int return_status;
    if (waitpid(child_pid, &return_status, 0) == -1) {
        perror("waitpid");
        exit(EXIT_FAILURE);
    }
# }}}

# {{{ Check errors
# Standard function call
snippet     cef
options     head
    if ((${1:FUNC}) == -1) {
        perror("${1:FUNC}");
        exit(EXIT_FAILURE);
    }
# Check value
snippet     cev
options     head
    if (${1:ARG} == ${2:VALUE}) {
        perror("${3:FUNC}");
        exit(EXIT_FAILURE);
    }
# Check NULL
snippet     cevn
options     head
    if (${1:ARG} == NULL) {
        perror("${2:FUNC}");
        exit(EXIT_FAILURE);
    }
# Check -1
snippet     cevm
options     head
    if (${1:ARG} == -1) {
        perror("${2:FUNC}");
        exit(EXIT_FAILURE);
    }
# }}}

# {{{ Commonly used functions
snippet kbhit
    static int kbhit(void)
    {
      struct termios oldt, newt;
      int ch;
      int oldf;

      tcgetattr(STDIN_FILENO, &oldt);
      newt = oldt;
      newt.c_lflag &= ~(ICANON | ECHO);
      tcsetattr(STDIN_FILENO, TCSANOW, &newt);
      oldf = fcntl(STDIN_FILENO, F_GETFL, 0);
      fcntl(STDIN_FILENO, F_SETFL, oldf | O_NONBLOCK);
      ch = getchar();
      tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
      fcntl(STDIN_FILENO, F_SETFL, oldf);
      if (ch != EOF) {
        ungetc(ch, stdin);
        return 1;
      }

      return 0;
    }

snippet kbhitf
    if (kbhit() == 1) {
        char c = getchar();
        if (c == 32) {
            printf("\n");
            ${1:ACTION}
            printf("Press <Space> for statistics or <Esc> for exit\n");
        } else if (c == 27) break;
    }

snippet int_from_bytes
    static int int_from_bytes(char *buf, int pos, int num)
    {
         unsigned char tmp[num];
         unsigned int acc = 0;
         int i, t = 0;
         for (i=0;i<num;i++)
             tmp[i] = buf[(pos + i)];
         for (i=0;i<num;i++)
             acc += tmp[i] << (8 * i);
         return acc;
    }
# }}}

# vim:fdm=marker:foldlevel=0:foldenable:
