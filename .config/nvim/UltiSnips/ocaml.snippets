snippet pr
Printf.printf "${0}\n";
endsnippet

snippet prd
Printf.printf "%s:%i: ${0}\n" __FILE__ __LINE__;
endsnippet

snippet prl
Printf.printf "`!p snip.rv = snip.basename`:`!p snip.rv='%d'%snip._end[0]`: $1\n" $2;
endsnippet

snippet be
begin
	${VISUAL}$0
end
endsnippet

snippet li
List.iter
  ${1:list}
  ~f:(fun ${2:e} -> $3);
endsnippet

snippet lfl
List.fold_left
  ${1:list}
  ~init:${2:[]}
  ~f:(fun acc ${3:v} -> ${0})
endsnippet

snippet lsc
List.fold_left ${1:list} ~init:[] ~f:(fun acc v -> acc @ [${2:v}]) |> String.concat ~sep:", "
endsnippet

snippet modcomp
module Comp = struct
  module T = struct
      type t = ${1:Foo | Bar} [@@deriving sexp,compare]
  end
  include T
  include Comparable.Make(T)
end
endsnippet

snippet mmk
Map.empty (${1:module Int})
endsnippet

snippet htmk
Caml.Hashtbl.create ${1:42}
endsnippet

snippet htit
Caml.Hashtbl.iter (fun k v -> $0) ${1:ht}
endsnippet

snippet qmk
Queue.create ()
endsnippet

snippet uniq
let ${1:uniq} =
  let r = ref 0 in
  fun () -> incr r;
    !r
endsnippet

snippet fstartswith
let startswith s1 s2 =
  let len1 = String.length s1 and len2 = String.length s2 in
  if len1 < len2 then false
  else
    let sub = String.sub s1 0 len2 in
    String.equal sub s2
endsnippet

snippet fendswith
let endswith s1 s2 =
  let len1 = String.length s1 and len2 = String.length s2 in
  if len1 < len2 then false
  else
    let sub = String.sub s1 (len1 - len2) len2 in
    String.equal sub s2
endsnippet

snippet nextid
let next_id =
  let n = ref (-1) in
  fun () -> incr n; !n
endsnippet
